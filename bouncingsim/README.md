# BouncingSim

A challenging physics simulation benchmark for 2D bouncing-ball dynamics in polygonal containers, designed for studying program synthesis, geometry-aware reasoning, and reinforcement learning with verification rewards.

## Table of Contents
- [Introduction](#introduction)
- [Key Features](#key-features)
- [Scene Types](#scene-types)
- [Quick Usage: Loading from Hugging Face](#quick-usage-loading-from-hugging-face)
- [Quick Start: Dataset Generation](#quick-start-dataset-generation)
- [Verification Server](#verification-server)
- [Using with RLVR (Reinforcement Learning with Verification Rewards)](#using-with-rlvr)
- [Generalization Axes](#generalization-axes)

## Introduction

BouncingSim transforms the widely-used 2D bouncing-ball simulation taskâ€”often treated as a proxy for geometry-aware reasoning in LLMsâ€”into a rigorous, verifiable benchmark. The goal is to synthesize a program that simulates elastic collisions in polygonal containers and returns the exact object state at a queried timestamp. Strong solutions require precise collision detection/response and numerically stable integration.

**Task Design**: Instead of informal, visually judged demos, we provide:
- **Verifiable**: Each prompt specifies a deterministic initial state (positions, velocities, container geometry); the program must output the object's location at a target time and is scored against an oracle
- **Synthesizable**: Instances are generated by varying configurations, with ground-truth trajectories produced by [Box2D](https://box2d.org/)
- **Composable**: Single-skill families (e.g., `ROTOBJ`, `ROTBOX`) can be combined into multi-skill families (e.g., `ROTOBJ_ROTBOX`)
- **Difficulty-Controlled**: We vary polygon vertex counts, object speeds, box motion, gravity, and the number of objects/boxes to create **Basic** â†’ **Easy** â†’ **Medium** â†’ **Hard** â†’ **Extreme** difficulty tiers

## Key Features

- **ðŸŽ¯ 6 Physics Families**: Rotating objects, rotating boxes, moving boxes, gravity variations, multiple boxes, multiple objects
- **ðŸ“Š 5 Difficulty Levels**: Basic, Easy, Medium, Hard, Extreme
- **ðŸ”„ Automatic Generation**: Parameterized scene generators for infinite problem variations
- **âœ… Built-in Verification**: Box2D-based physics engine with precise correctness checking


## Scene Types

In the codebase, we use **letters** to denote different physics setups:

### Single-Skill Families

- **A (ROT_OBJ)** - Rotating Objects: Objects spin while bouncing
- **B (ROT_BOX)** - Rotating Boxes: Container rotates around its center
- **C (MOV_BOX)** - Moving Boxes: Container translates along paths (circular, Lissajous curves, piecewise linear)
- **D (GRAVITY)** - Gravity Variations: Time-varying, tilted, chaotic, or extreme gravity conditions
- **F (MULTI_BOX)** - Multiple Boxes: Multiple containers with different geometries
- **G (MULTI_OBJ)** - Multiple Objects: Multiple balls bouncing simultaneously

### Compositional Families

Single-skill families can be combined to create more complex scenarios:

- **AB (ROTOBJ_ROTBOX)** - Both objects and container rotate
- **AC (ROTOBJ_MOVBOX)** - Rotating objects in a moving container
- **AD (ROTOBJ_GRAVITY)** - Rotating objects with gravity variations
- **BC (ROTBOX_MOVBOX)** - Rotating and moving container
- **BD (ROTBOX_GRAVITY)** - Rotating container with gravity
- **CD (MOVBOX_GRAVITY)** - Moving container with gravity
- ... and many more combinations!

## Quick Usage: Loading from Hugging Face

We provide pre-generated datasets on Hugging Face for immediate use. You can load them directly without generating problems locally.

### Available Datasets

All datasets are available at [https://huggingface.co/bouncingsim/datasets](https://huggingface.co/bouncingsim/datasets)

**Example Datasets:**
- `bouncingsim/bouncingsim-ROTOBJ_ROTBOX-basic` - Rotating objects and boxes (Basic)
- `bouncingsim/bouncingsim-ROTOBJ_ROTBOX-easy` - Rotating objects and boxes (Easy)
- `bouncingsim/bouncingsim-MOVBOX_GRAVITY-basic` - Moving boxes with gravity (Basic)
- `bouncingsim/bouncingsim-MULTIOBJ_MULTIOBJ-easy` - Multiple objects (Easy)
- ... and many more covering all combinations and difficulty levels!

### Python Usage

#### Load a Single Dataset

```python
from datasets import load_dataset

# Load a specific difficulty level
dataset = load_dataset("bouncingsim/bouncingsim-ROTOBJ_ROTBOX-basic")
```

## Quick Start: Dataset Generation

### Full Pipeline

Run the example generation pipeline (5 problems in each setting):

```bash
bash run_generation.sh
```

This script generates scenes for all single-skill families (A-G) at all difficulty levels.

### Custom Generation

Generate specific scene types:

```bash
# Generate single scene type
python generate.py \
    --types A \
    --difficulties 0 1 2 3 4 \
    --scenes-per-config 5 \
    --dataset-name scene_A \
    --timestamps-per-scene 15 \
    --separate-by-difficulty \
    --prompt-setting function

# Generate composite scene type
python generate.py \
    --types AB \
    --difficulties 0 1 \
    --scenes-per-config 10 \
    --dataset-name scene_AB \
    --timestamps-per-scene 20
```

**Key Parameters:**
- `--types`: Scene type letters (A, B, C, D, F, G, or combinations like AB, CD)
- `--difficulties`: Difficulty levels (0=Basic, 1=Easy, 2=Medium, 3=Hard, 4=Extreme)
- `--scenes-per-config`: Number of scenes per (type, difficulty) combination
- `--timestamps-per-scene`: Number of timestamps to query per scene
- `--tolerance`: Error tolerance in pixels (default: 50.0)
- `--prompt-setting`: "list" (reveals timestamps) or "function" (hides timestamps)
- `--separate-by-difficulty`: Create separate files per difficulty level

**Output:**
- Scene files: `data/scenes/{dataset_name}/scenes_{type}/{difficulty}/scene_{type}_{difficulty}_{N}.json`
- Dataset files: `data/datasets/dataset_{dataset_name}_{difficulty}.jsonl`

## Verification Server

For large-scale evaluation and RLVR training, we provide a FastAPI-based verification server.

### Launch the Server

```bash
uvicorn bouncingsim.verifier.ballsim_api:app --host 0.0.0.0 --port 1234 &
```

### API Endpoints

#### Health Check

```bash
curl -X GET http://localhost:1234/health
```

#### Verify Solution

```bash
curl -X POST http://localhost:1234/test_program \
  -H "Content-Type: application/json" \
  -d '{
    "scene_id": "A_0_1",
    "program": "def predict_position(t):\n    # Your physics simulation code\n    return [[x, y]]",
    "tests": ["assert check_distance(predict_position(1.0), [[500.0, 500.0]]) <= 50"],
    "timeout": 5.0
  }'
```


## Using with RLVR

BouncingSim is designed for **Reinforcement Learning with Verification Rewards** (RLVR), where models learn from sparse binary feedback (correct/incorrect) rather than supervised learning.

### Training Code

We provide complete training infrastructure in the companion repository:

**Repository**: [open-instruct/merge-code-utils](https://github.com/sunyiyou/open-instruct/tree/merge-code-utils)

### Setup Verification Infrastructure

#### 1. Deploy Verification Nodes

For distributed training, deploy multiple verification servers behind an nginx load balancer:

```bash
# Script to setup verification nodes with nginx
bash configs/beaker_configs/ballsim_api_setup.sh
```

Script available at: [ballsim_api_setup.sh](https://github.com/sunyiyou/open-instruct/blob/merge-code-utils/configs/beaker_configs/ballsim_api_setup.sh)

#### 2. Integrate with Training Loop

The training code uses a `BouncingSimVerifier` class to interface with the verification servers:

**Implementation**: [ground_truth_utils.py#L1049](https://github.com/sunyiyou/open-instruct/blob/merge-code-utils/open_instruct/ground_truth_utils.py#L1049)

Key features:
- **Per-test accuracy**: Percentage of test cases passed
- **Full-pass rate**: Binary success (all tests must pass)
- **Batched verification**: Process multiple solutions in parallel
- **Timeout handling**: Graceful handling of infinite loops or slow code
- **Retry logic**: Automatic retries on server failures
- **Load balancing**: Distribute verification across multiple servers

## Generalization Axes

To study systematic generalization in reinforcement learning, we design three explicit generalization axes following the OMEGA framework:

### 1. Exploratory Generalization

**Training**: Standard box sizes with relatively sparse collisions  
**Testing**: Smaller containers that induce denser and more frequent collisions

This tests whether models can adapt to quantitatively different collision densities and frequencies without qualitative changes to the physics.

### 2. Compositional Generalization

**Training**: Isolated distinct skills in separate datasets
- `ROTOBJ` (A) - Handle rotating objects only
- `ROTBOX` (B) - Handle rotating boxes only

**Testing**: Combined scenarios requiring both skills
- `ROTOBJ_ROTBOX` (AB) - Both object and box rotate simultaneously

This tests whether models can compose separately learned skills into integrated behaviors.

### 3. Transformative Generalization

**Training**: Common variants with typical dynamics
- Standard `ROTBOX`, `MOVBOX`, `GRAVITY` scenarios

**Testing**: Qualitatively different dynamics
- Special initial conditions yielding perfectly periodic trajectories
- Exotic parameter regimes not seen during training

This tests whether models can extrapolate to fundamentally different behavioral patterns.

## Contributor

- **Yiyou Sun** 
- **Yuhan Cao** 